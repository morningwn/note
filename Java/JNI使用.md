# JNI使用
>最近闲着没事，研究了一下Java的native方法是怎么实现的，记一下流程

## 创建native方法
```java
public class JNIUtils {
    public static native String sayHello(String name);
}
```
## 编译生成头文件
```sh

javac .\JNIUtils.java

# 需要注意，这个命令要在根路径执行
javah com.example.demo.utils.JNIUtils
```
对应的头文件如下：
```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_example_demo_utils_JNIUtils */

#ifndef _Included_com_example_demo_utils_JNIUtils
#define _Included_com_example_demo_utils_JNIUtils
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_example_demo_utils_JNIUtils
 * Method:    sayHello
 * Signature: (Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_example_demo_utils_JNIUtils_sayHello
  (JNIEnv *, jclass, jstring);

#ifdef __cplusplus
}
#endif
#endif
```

## 编写方法
```c
#include "jni.h"
#include "com_example_demo_utils_JNIUtils.h"
#include <stdio.h>
#include <string.h>

JNIEXPORT jstring JNICALL Java_com_example_demo_utils_JNIUtils_sayHello(JNIEnv *env, jclass aClass, jstring jstr)
{

    char *hello = "hello, ";
    // 将Java的字符串类型转换为char数组
    const char *str = (*env) -> GetStringUTFChars(env, jstr, 0);
    int length = strlen(hello) + strlen(str);

    char res[length];

    strcpy(res, hello);
    strcat(res, str);
    printf("res is: %s", res);

    // 释放Java字符串类型和char数组的关联关系
    (*env) -> ReleaseStringUTFChars(env, jstr, str);
    
    // 创建新的Java字符串类型
    return (*env) -> NewStringUTF(env, res);
}
```
## 编译生成dll文件
我用的cmake，需要注意的是C代码里面引入了jni的库，编译的时候加进去就行了，这个库去本地安装的jdk的include文件夹里面找就行了

## 最后运行
>在代码里面加载这个库然后调用就行了
```java
public class JNIUtils {
    static{
        try{
            System.loadLibrary("/lib/libJNIUtils");
        }catch(UnsatisfiedLinkError e){
            System.err.println("Native code library failed to load.\n" + e);
            System.exit(1);
        }
    }
    public static native String sayHello(String name);
}

```