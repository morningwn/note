# 类加载过程

>以下大部分来自《深入理解Java虚拟机——JVM高级特性与最佳实践》这本书，少部分内容是本人自己的理解，如有问题还请指正。
## 概述
虚拟机把Java字节码从硬盘、网络或者是其他的地方加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

与那些在编译时需要进行连接工作的语言不通，在Java语言中Class文件的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会使类的加载时稍微增加一些性能开销，但是会为Java应用提供高度的灵活性，Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。例如，如果编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类；用户可以通过Java预定义的和自定义类加载器，让一个本地的应用程序可以在运行时从网络或者其他的地方加载一个二进制流作为程序代码的一部分，这种组装应用程序的方式目前已广泛应用于Java程序之中。从最基础的Applet、JSP到相对复杂的OSGI技术，都使用了Java语言运行时类加载的特性。

Java虚拟机的类加载过程进行细分为：加载、验证、准备、解析、初始化；其中验证、准备、解析三个阶段又通常被统称为连接。其中，加载、验证、准备、初始化这几个阶段是按照顺序执行的，而解析则不一定，在一些情况下可以在初始化阶段之后才开始，这是为了支持Java语言的运行时绑定。

## 加载
主要有以下三个阶段：

 1. 通过一个类的全限定名获取此类的二进制字节流；
 2. 将这个字节流所代表的静态存储结果转化为方法区运行时的数据结构；
 3. 在内存中生成一个代表此类的`java.lang.Class`对象，作为方法区这个类的各种数据的访问入口。

### 字节码的来源
其中Class文件的来源不确定，可以是本地硬盘、也可以是网络又或者是其他的地方。

也可能是通过其他语言转化后的字节码，如Scala。只要字节码符合JVM的规范，那就可以解释执行。

### java.lang.Class对象存放位置
另外，在虚拟机的规范中，对于Class对象并没有明确其存放位置。对于HotSpot虚拟机而言，在类型数据被妥善安置在方法区之后，会在堆中创建一个`java.lang.Class`对象，作为程序访问方法区中的类型数据的外部接口。
### 其他
最后，加载阶段与连接阶段的部分内容是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始。
## 验证
因为Java的字节码文件的来源不一定，所以为了确保Java字节码文件中的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全，所以要进行一次文件的验证。

主要进行以下几个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符合引用验证。

### 文件格式验证
这一个阶段要验证字节流是否符合Class文件格式的规范，并且能够被当前版本的虚拟机处理。

在通过这个阶段的验证后，字节流才会进入内存的方法区中进行存储。

### 元数据验证
此阶段是对字节码描述的信息进行语义分析，保证其符合Java的语言规范。注意：不是Class文件格式规范。

上一个阶段保证加载的数据是一个格式正确的Class文件，但是不保证其能够执行，也就是其可能会存在编译错误或者是其他的更加隐蔽的问题。

这个阶段要进行的操作则是对类的元数据进行校验，保证不存在不符合Java语言规范的元数据信息。

### 字节码验证
这个阶段是整个验证过程中最复杂的一个阶段。

主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在这个阶段对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。

另外，一个类方法体的字节码没有通过字节码验证，那一定是有问题的；但如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。

### 符号引用验证
最后一个阶段的校验发生在虚拟机符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。


>最后，对于虚拟机的类加载机制来说，验证阶段是一个非常重要、但不是一定必要的阶段（因为对程序的运行期没有影响）。如果运行的全部代码（包括自己编写的以及第三方包中的代码）都已经被反复使用和验证过，那么在实施阶段就可以考虑使用-`Xverify:none`参数来关闭大部分类的验证措施，以缩短虚拟机类加载的时间。

## 准备
在这个阶段正式为类变量分配内存并设置初始值的阶段，这些遍历所使用的内存都将在方法区中进行分配。注意：是对类变量进行内存分配并设置初始值。

需要注意的是，在这个阶段对类变量分配内存，这个时候类变量的值是默认初始值，比如整型数默认值为0。


此时的类变量并不算是已经初始化完毕，这个时候的数据可以对其进行赋值操作，但是并不能进行输出操作，否则会报错。

下面一个小例子可以说明此种情况：
```java
public class Main {
    static {
        a = 23;
    }
    private static int a = 1;

    public static void main(String[] args) {
        System.out.println(a);
    }
}
```
>最后的输出结果是1

首先为类变量a分配内存，然后根据代码出现的位置，对a进行赋值操作，a先是23，最后变为1。另外就是在静态代码块中对a使用`print`进行输出，会报错，错误信息是非法前向引用。

## 解析
解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。

### 符号引用
符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。

符号引用与虚拟机实现的内存布局无关，但是他们能接受的符号引用必须都是一致的，具体的形式自己去找Java虚拟机的规范。

需要注意的一点就是符号引用的目标并不一定是已经加载到虚拟机内存中的内容。

### 直接引用
直接引用可以是直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。

直接引用与虚拟机实现的内存布局是相关的，同一个符号引用在不同虚拟机翻译出来的直接引用一般不会相同。

如果有了直接引用，那么引用的目标必定已经在虚拟机的内存中存在。

### 解析阶段发生的时间
Java虚拟机规范并未规定解析阶段发生的具体时间，但是要求了在执行操作符号引用的字节码指令之前，对其进行解析。我的理解就是在用到一个符号引用之前进行解析操作就行了。

## 初始化
类的初始化是类加载过程的最后一个步骤。

在这个阶段会执行类构造器`<clinit()>`方法，这个方法是Javac编译器的产物，是由编译器自动收集类中的所有类变量的赋值动作和静态语句块，然后进行合并得到的，编译器收集的顺序是由语句在源文件中出现的顺序决定的。

另外就是`<clinit>()`方法对于接口或者类来说并不是必须的，如果一个类中没有静态代码块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成`<clinit>()`方法。

Java虚拟机会保证`<clinit>()`方法会在子类方法的执行前先执行，但是对于接口则没有这种要求，只有当父接口中定义的变量被使用的时候父接口才会被初始化。

最后就是Java虚拟机要保证一个类的`<clinit>()`方法在多线程的环境中只被执行一次，如果多个线程同时去初始化一个类，那么只有一个线程去执行这个方法，其他的线程都有阻塞等待，直到活动线程执行完毕`<clinit>()`方法。